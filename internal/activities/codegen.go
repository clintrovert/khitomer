package activities

import (
	"context"
	"fmt"
	"os"
	"path/filepath"

	"go.temporal.io/sdk/activity"
	"go.uber.org/zap"

	"github.com/clintrovert/khitomer/pkg/types"
)

// CodeGenerationActivity generates or modifies code based on the plan
func CodeGenerationActivity(ctx context.Context, task *types.Task, plan *types.ImplementationPlan, repoPath string) (CodeGenerationResult, error) {
	logger := activity.GetLogger(ctx)
	logger.Info("generating code",
		zap.String("jira_ticket", task.JiraTicketID),
		zap.String("repo_path", repoPath),
	)

	result := CodeGenerationResult{
		ModifiedFiles: []string{},
		CreatedFiles:  []string{},
		Success:       true,
	}

	// For each step in the plan, generate/modify code
	for _, step := range plan.Steps {
		if step.ActivityType != "codegen" {
			continue
		}

		// This is a placeholder - in a real implementation, you would:
		// 1. Use AI to generate code based on the step description
		// 2. Write the code to the appropriate files
		// 3. Track which files were modified/created

		logger.Info("processing codegen step",
			zap.Int("order", step.Order),
			zap.String("description", step.Description),
		)

		// Example: Create a placeholder file for demonstration
		if len(plan.FilesToCreate) > 0 {
			for _, file := range plan.FilesToCreate {
				filePath := filepath.Join(repoPath, file)
				if err := os.MkdirAll(filepath.Dir(filePath), 0755); err != nil {
					logger.Warn("failed to create directory", zap.Error(err))
					continue
				}

				if _, err := os.Stat(filePath); os.IsNotExist(err) {
					// Create placeholder file
					content := fmt.Sprintf("// Generated by Khitomer for %s\n// %s\n", task.JiraTicketID, step.Description)
					if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
						logger.Warn("failed to create file", zap.String("file", file), zap.Error(err))
						continue
					}
					result.CreatedFiles = append(result.CreatedFiles, file)
				}
			}
		}
	}

	result.Summary = fmt.Sprintf("Generated code for %d files, created %d files", len(result.ModifiedFiles), len(result.CreatedFiles))
	return result, nil
}

